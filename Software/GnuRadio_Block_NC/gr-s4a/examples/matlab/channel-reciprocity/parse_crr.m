%% Channel Reciprocity Tester
% This script is used to parse data generated by
% "gr-s4a/examples/channel-reciprocity/channel_reciprocity_usrp.grc"
% When you run this flow graph on different nodes such as 'Master',
% 'Slave' and 'Spy', then, you can put the recorded data files in this
% folder and visualize them by running this script.

close all
clc
%% Parameters
Noc         = 48;                   % Occupied tones
Nplot       = 20;                   % Subcarrier to be plotted (27, 33, 40)
t_res       = 100;                  % Time resolution of the results (msec)
avg_window  = 300;                  % Averaging window (msec)
normalize   = 0;                    % Normalize?

shift_x     = [0 0 0 0];            % Relavite shift for each node in x axis
shift_y     = [0 0 0 0];            % Relative shift for eac node in y axis

master_node_file    = 'metrics_master.dump';
slave_node_file     = 'metrics_slave.dump';
spy_node_file       = 'metrics_spy.dump';
spy_enabled = 1;                    % If we have SPY node that captures all the 
                                    % traffic between MASTER and SLAVE

%% Data Model
Node = '';
% Raw Data
Node.raw            = [];                   % Raw data (parsed from the file)

% Reshaped Data
Node.id             = 0;                    % Node id
Node.name           = 'Node';               % Node name
Node.friendName     = 'NodeFriend';         % Partner node
Node.t              = [];                   % Timestamp in ms
Node.snr            = [];                   % SNR
Node.h_t            = [];                   % Channels in frequency domain
Node.h_f            = [];                   % Channels in time domain

% Decimated Data
Node.decimated          = '';
Node.decimated.t        = [];
Node.decimated.snr      = [];
Node.decimated.h_t      = [];
Node.decimated.h_f      = [];

% Averaged Data
Node.decimated.averaged         = '';
Node.decimated.averaged.t       = [];
Node.decimated.averaged.snr     = [];
Node.decimated.averaged.h_t     = [];
Node.decimated.averaged.h_f     = [];
Node.decimated.averaged.h_f_ang  = [];

%% Parse Data from Nodes
% Read raw data
n1              = Node;
n1.raw          = read_complex_binary(master_node_file);
n1.id           = 170;
n1.name         = 'Master';
n1.friendName   = 'Slave';

n2              = Node;
n2.id           = 187;
n2.raw          = read_complex_binary(slave_node_file);
n2.name         = 'Slave';
n2.friendName   = 'Master';

nodes = {};
nodes{1} = n1;
nodes{2} = n2;

if spy_enabled == 1
    % Search master and slave inside the recorded SPY data
    n3              = Node;
    n3.id           = 200;
    n3.raw          = [];
    n3.name         = 'Spy';
    n3.friendName   = 'Master';

    n4              = Node;
    n4.id           = 200;
    n4.raw          = [];
    n4.name         = 'Spy';
    n4.friendName   = 'Slave';

    spy_raw = read_complex_binary(spy_node_file);
    spy_raw = reshape(spy_raw(...
                            1:end-mod(numel(spy_raw),4+Noc)),...
                            4+Noc,[]);
                        
    for idx=1:size(spy_raw,2)
        if spy_raw(4,idx) == nodes{1}.id
            n3.raw = [n3.raw spy_raw(:,idx)];
        elseif spy_raw(4,idx) == nodes{2}.id
            n4.raw = [n4.raw spy_raw(:,idx)];            
        end
    end
    
    idx = 3;
    if size(n3.raw,2) > 0
        nodes{idx} = n3;   
        nodes{idx}.raw = reshape(nodes{idx}.raw,1,[]);
        idx = idx + 1;
    end

%     if size(n4.raw,2) > 0
%         nodes{idx} = n4;
%         nodes{idx}.raw = reshape(nodes{idx}.raw,1,[]);
%         idx = idx + 1;
%     end
end

% Reshapes the raw data from serial to parallel
for idx=1:numel(nodes)
    nodes{idx}.raw = reshape(nodes{idx}.raw(...
                            1:end-mod(numel(nodes{idx}.raw),4+Noc)),...
                            4+Noc,[]);
    nodes{idx}.t(1)      = nodes{idx}.raw(1,1);
    nodes{idx}.snr(1)    = nodes{idx}.raw(2,1);
    nodes{idx}.h_f       = nodes{idx}.raw(3:2+Noc,1);
    nodes{idx}.h_t       = ifft(nodes{idx}.raw(5:4+Noc,1),Noc);

    % Removes duplicated entries and maps the metrics such as t, snr, h...
    for jdx=2:size(nodes{idx}.raw,2)
        if nodes{idx}.raw(1,jdx) ~= nodes{idx}.raw(1,jdx - 1)
            nodes{idx}.t       = [nodes{idx}.t,...
                                  nodes{idx}.raw(1,jdx)];
                              
            nodes{idx}.snr     = [nodes{idx}.snr,...
                                  nodes{idx}.raw(2,jdx)];
                              
            nodes{idx}.h_f     = [nodes{idx}.h_f,...
                                  nodes{idx}.raw(5:4+Noc,jdx)];
                                   
            nodes{idx}.h_t     = [nodes{idx}.h_t,...
                                  ifft(nodes{idx}.raw(5:4+Noc,jdx),Noc)]; 
        end
    end
end

% Decimates the results for the given time resolution
for idx=1:numel(nodes)
    tmin = nodes{idx}.t(1);
    tmax = nodes{idx}.t(end);
    for jdx=tmin:t_res:tmax
        % Picks one value set with best SNR condition
        jdx1 = find(nodes{idx}.t >= jdx,1);
        jdx2 = find(nodes{idx}.t >= (jdx + t_res),1);- 1;
        if jdx2 > jdx1
            [maxidx maxval] = max(nodes{idx}.snr(jdx1:jdx2));
            jdx_best = (jdx1 + maxval - 1);
        else
            jdx_best = jdx1;
        end
        nodes{idx}.decimated.t   = [nodes{idx}.decimated.t,...
                                    jdx];
        nodes{idx}.decimated.snr = [nodes{idx}.decimated.snr,...
                                    nodes{idx}.snr(jdx_best)];
        nodes{idx}.decimated.h_t = [nodes{idx}.decimated.h_t,...
                                    nodes{idx}.h_t(:,jdx_best)];
        nodes{idx}.decimated.h_f = [nodes{idx}.decimated.h_f,...
                                    nodes{idx}.h_f(:,jdx_best)];
    end
end
clear tmin tmax jdx1 jdx2 maxidx maxval

% Apply shifting in x axis
shift_x_diff = max(shift_x) - min(shift_x);
shift_x_abs = shift_x - round(mean(shift_x));
shift_x_abs = shift_x_abs + (sign(min(shift_x_abs))*min(shift_x_abs));

shift_y_diff = max(shift_y) - min(shift_y);
shift_y_abs = shift_y - round(mean(shift_y));
shift_y_abs = shift_y_abs + (sign(min(shift_y_abs))*min(shift_y_abs));

if mod(shift_x_abs,t_res) ~= 0
    error(['Shifting in x axis should be',...
           ' multiple of time resolution (t_res)']);
end

for idx=1:numel(nodes)
   s1 = shift_x_abs(idx);
   s2 = shift_x_diff - s1;
   nodes{idx}.decimated.t = nodes{idx}.decimated.t(1+s1:end-s2);
   nodes{idx}.decimated.snr = nodes{idx}.decimated.snr(1+s1:end-s2);
   nodes{idx}.decimated.h_t = nodes{idx}.decimated.h_t(:,1+s1:end-s2);
   nodes{idx}.decimated.h_f = nodes{idx}.decimated.h_f(:,1+s1:end-s2);
end
clear s1 s2

% Normalize if it is enabled
if normalize == 1
    for idx=1:numel(nodes)
      nodes{idx}.decimated.h_t = nodes{idx}.decimated.h_t ./ max(max(abs(nodes{idx}.decimated.h_t)));
      nodes{idx}.decimated.h_f = nodes{idx}.decimated.h_f ./ max(max(abs(nodes{idx}.decimated.h_f)));
    end   
end

% Average the results respect to the time window
avg_step = avg_window / t_res;
if mod(avg_window,t_res) ~= 0
   error(['Averaging window (avg_window = ',...
         num2str(avg_window),...
         ') should be multiple of time resolution (t_res = ',...
         num2str(t_res),...
         ')']); 
end
for idx=1:numel(nodes)
    decimated_node_sz =  numel(nodes{idx}.decimated.t);
    for jdx=1:avg_step:(decimated_node_sz-avg_step)
        nodes{idx}.decimated.averaged.t     = ...
                    [nodes{idx}.decimated.averaged.t,...
                     nodes{idx}.decimated.t(jdx)];
        nodes{idx}.decimated.averaged.snr   = ...
                    [nodes{idx}.decimated.averaged.snr,...
                     mean(nodes{idx}.decimated.snr(jdx:jdx+avg_step-1),2)];
        nodes{idx}.decimated.averaged.h_t   = ...
                    [nodes{idx}.decimated.averaged.h_t,...
                     mean(abs(nodes{idx}.decimated.h_t(:,jdx:jdx+avg_step-1)),2)];
        nodes{idx}.decimated.averaged.h_f   = ...
                    [nodes{idx}.decimated.averaged.h_f,...
                     mean(abs(nodes{idx}.decimated.h_f(:,jdx:jdx+avg_step-1)),2)];
        
        ang_temp = phase(reshape(nodes{idx}.decimated.h_f(:,jdx:jdx+avg_step-1),[],1));
        ang_temp = reshape(ang_temp,Noc,[]);
        nodes{idx}.decimated.averaged.h_f_ang   = ...
                    [nodes{idx}.decimated.averaged.h_f_ang,...
                     mean(ang_temp,2)];
    end
end

%% Results
% % Create figure
% figure1 = figure('XVisual',...
%           '0x118 (TrueColor, depth 24, RGB mask 0xff0000 0xff00 0x00ff)');
% 
% % Create axes
% axes1 = axes('Parent',figure1,'YGrid','on','XGrid','on','FontSize',12,...
%     'FontName','Helvetica');
% box(axes1,'on');
% hold(axes1,'all');

data                = '';       % Data to plot
data.t              = [];       % Time 
data.snr            = [];       % SNR
data.h_f            = [];       % Channel gains in frequency
data.h_f_sel_gain   = [];       % Selected subband of the channel in frequency (gain)
data.h_f_sel_ang    = [];       % Selected subband of the channel in frequency (angle)
data.h_t            = [];       % Channel gains in time

t_diff_min = Inf;
node_ref = 1;
for idx=1:numel(nodes)
    t_start = nodes{idx}.decimated.averaged.t(1);
    t_end   = nodes{idx}.decimated.averaged.t(end);
    t_diff = t_end - t_start;
    if t_diff < t_diff_min
       t_diff_min = t_diff;
       node_ref = idx; 
    end
end
data.t = 0:t_diff_min/numel(nodes{node_ref}.decimated.averaged.t):t_diff_min-1;

for idx=1:numel(nodes)
    data.snr = [data.snr;
                nodes{idx}.decimated.averaged.snr(end-numel(data.t)+1:end)];

    data.h_t = [data.h_t;
                shift_y(idx)+reshape(nodes{idx}.decimated.averaged.h_t(:,end-numel(data.t)+1:end),1,[])];
            
    data.h_f = [data.h_f;
                shift_y(idx)+reshape(nodes{idx}.decimated.averaged.h_f(:,end-numel(data.t)+1:end),1,[])];


            
    data.h_f_sel_gain = [data.h_f_sel_gain;
                shift_y(idx)+reshape(nodes{idx}.decimated.averaged.h_f(Nplot,end-numel(data.t)+1:end),1,[])];

    data.h_f_sel_ang = [data.h_f_sel_ang;
                     reshape(nodes{idx}.decimated.averaged.h_f_ang(Nplot,end-numel(data.t)+1:end),1,[])];
                 

            
end

% Create legend texts
legend_nodes = {};
for idx=1:numel(nodes)
    legend_temp = [nodes{idx}.friendName ' to ' nodes{idx}.name];
    legend_snr = mean(nodes{idx}.decimated.averaged.snr);
    legend_temp = [legend_temp ', SNR = ' num2str(legend_snr) ' dB'];
    legend_nodes{idx} = legend_temp;
end
clear legend_temp legend_snr

% Create 'normalized' text
normalized_text = '';
if normalize == 1
   normalized_text = 'Normalized ';
end
    

plot(data.t/1000,data.snr.');
title('SNR change by time')
xlabel('Seconds');
ylabel('SNR (dB)');
legend(legend_nodes)

figure
plot(data.h_f.');
title([normalized_text 'Channel estimations in frequency']);
legend(legend_nodes)

% figure
% plot(data.h_t.');
% title([normalized_text 'Channel estimations in time']);
% legend(legend_nodes)

figure
plot(data.t/1000,data.h_f_sel_gain.');
title(['Time evolution of the channel gains (' num2str(Nplot),...
        'th subband in ' num2str(Noc) ' subbands)']);
xlabel('Seconds');
ylabel([normalized_text 'Channel gain']);
legend(legend_nodes)

% figure
% plot(data.t/1000,data.h_f_sel_ang.');
% title(['Time evolution of the angle (' num2str(Nplot),...
%         'th subband in ' num2str(Noc) ' subbands)']);
% xlabel('Seconds');
% ylabel([normalized_text 'Angle']);
% legend(legend_nodes)

for idx=1:numel(nodes)
    disp(['',...
          num2str(legend_nodes{idx}),...
          ', Acquisition rate = ',...
          num2str(round((numel(nodes{idx}.t)*1000)...
          / (nodes{idx}.t(end) - nodes{idx}.t(1)))),...
          ' Hz']);
end
